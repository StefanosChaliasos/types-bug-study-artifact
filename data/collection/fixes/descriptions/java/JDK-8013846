FULL PRODUCT VERSION :
javac 1.7.0_10

ADDITIONAL OS VERSION INFORMATION :
This issue is not OS dependent, but I tested on 64-bit Windows 7 SP1
Microsoft Windows [Version 6.1.7601]

A DESCRIPTION OF THE PROBLEM :
The javac 1.7.0_10 compiler fails to reject code containing semantically equivalent generic method declarations.  Example source code is included with this bug report.  This code is correctly rejected by javac 1.6.0_37.

The example code contains two semantically equivalent declarations for a generic class method, but each has a distinct definition.  The compiler appears to always choose the first declaration when resolving method calls.

# Using javac 1.6.0_37:
$ javac -version
javac 1.6.0_37

$ javac t.java
t.java:10: <t1>smf(t1) is already defined in t
    static <t2 extends i2 & i1> Object smf(t2 x) {
                                       ^
1 error

# Using javac 1.7.0_10
$ javac -version
javac 1.7.0_10

$ javac t.java
<no errors>

$ java -version
java version  " 1.7.0_10 " 
Java(TM) SE Runtime Environment (build 1.7.0_10-b18)
Java HotSpot(TM) 64-Bit Server VM (build 23.6-b04, mixed mode)

$ java t
smf1

# Modify the source code to change the order of the smf() declarations.

$ javac t.java
<no errors>

$ java t
smf2

REGRESSION.  Last worked in version 6u31

STEPS TO FOLLOW TO REPRODUCE THE PROBLEM :
Compile the example source code using javac 1.7.0_10.

EXPECTED VERSUS ACTUAL BEHAVIOR :
EXPECTED -
The source code should be rejected with an error like that provided by javac 1.6.0_37.
ACTUAL -
No errors are produced and a .class file is generated by the compiler.  At run-time, the first declaration of the semantically equivalent generic method declaration is chosen when resolving method calls.

REPRODUCIBILITY :
This bug can be reproduced always.

---------- BEGIN SOURCE ----------
public class t {
    interface i1 {}
    interface i2 {}

    static <t1 extends i1 & i2> Object smf(t1 x) {
        System.out.println( " smf1 " );
        return null;
    }

    static <t2 extends i2 & i1> Object smf(t2 x) {
        System.out.println( " smf2 " );
        return null;
    }

    public static void main(String[] s) {
        class c implements i1, i2 {}
        smf(new c());
    }
}
---------- END SOURCE ----------

CUSTOMER SUBMITTED WORKAROUND :
Correct the erroneous source code.  However, this requires recognizing a run-time problem and debugging the code to determine that the  " wrong "  method implementation is getting called.