{cut IDEA log}resolveToInstruction: incorrect index 158 for label L40 in subroutine private fun verification(pluginDescriptor: PluginDescriptor,
                           ide: Ide,
                           ideDescriptor: IdeDescriptor,
                           params: VParams,
                           ideResolver: Resolver,
                           runtimeResolver: Resolver): Pair<Plugin?, VResult> {
    val (plugin: Plugin?, pluginLock: IFileLock?, badResult: VResult?) = createPlugin(pluginDescriptor, ide.version)
    if (badResult != null) {
      return null to badResult
    }
    try {
      val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor)
      if (badResult2 != null) {
        return null to badResult2
      }

      pluginResolver!!.use puse@ {
        val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options)
        val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx)

        try {
          dependenciesResolver.use {
            try {
              val checkClasses = getClassesForCheck(plugin, pluginResolver)
              val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath)

              VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) }

              val warnings = ctx.warnings +
                  (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) +
                  (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList())

              if (ctx.problems.isEmpty) {
                return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings)
              } else {
                return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings)
              }

            } catch (ie: InterruptedException) {
              throw ie
            } catch (e: Exception) {
              val message = "Failed to verify $pluginDescriptor with $ideDescriptor"
              LOG.error(message, e)
              throw RuntimeException(message, e)
            }
          }
        } finally {
          pluginLocks.forEach { it.release() }
        }

      }
    } finally {
      pluginLock?.releaseLock()
    }

  } with instructions [<START>, v(pluginDescriptor: PluginDescriptor), magic[FAKE_INITIALIZER](pluginDescriptor: PluginDescriptor) -> <v0>, w(pluginDescriptor|<v0>), v(ide: Ide), magic[FAKE_INITIALIZER](ide: Ide) -> <v1>, w(ide|<v1>), v(ideDescriptor: IdeDescriptor), magic[FAKE_INITIALIZER](ideDescriptor: IdeDescriptor) -> <v2>, w(ideDescriptor|<v2>), v(params: VParams), magic[FAKE_INITIALIZER](params: VParams) -> <v3>, w(params|<v3>), v(ideResolver: Resolver), magic[FAKE_INITIALIZER](ideResolver: Resolver) -> <v4>, w(ideResolver|<v4>), v(runtimeResolver: Resolver), magic[FAKE_INITIALIZER](runtimeResolver: Resolver) -> <v5>, w(runtimeResolver|<v5>), mark({ val (plugin: Plugin?, pluginLock: IFileLock?, badResult: VResult?) = createPlugin(pluginDescriptor, ide.version) if (badResult != null) { return null to badResult } try { val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } } finally { pluginLock?.releaseLock() } }), magic[IMPLICIT_RECEIVER](createPlugin(pluginDescriptor, ide.version)) -> <v6>, r(pluginDescriptor) -> <v7>, mark(ide.version), r(ide) -> <v8>, r(version|<v8>) -> <v9>, mark(createPlugin(pluginDescriptor, ide.version)), call(createPlugin(pluginDescriptor, ide.version), createPlugin|<v6>, <v7>, <v9>) -> <v10>, v(plugin: Plugin?), call(plugin: Plugin?, component1|<v10>) -> <v11>, w(plugin|<v11>), v(pluginLock: IFileLock?), call(pluginLock: IFileLock?, component2|<v10>) -> <v12>, w(pluginLock|<v12>), v(badResult: VResult?), call(badResult: VResult?, component3|<v10>) -> <v13>, w(badResult|<v13>), mark(if (badResult != null) { return null to badResult }), r(badResult) -> <v14>, r(null) -> <v15>, mark(badResult != null), call(badResult != null, equals|<v14>, <v15>) -> <v16>, jf(L2|<v16>), mark({ return null to badResult }), r(null) -> <v17>, r(badResult) -> <v18>, mark(null to badResult), call(null to badResult, to|<v17>, <v18>) -> <v19>, ret(*|<v19>) L1, jmp(L3), read (Unit), merge(if (badResult != null) { return null to badResult }|!<v20>) -> <v21>, mark(try { val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } } finally { pluginLock?.releaseLock() }), jmp?(L4), mark({ val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } }), magic[IMPLICIT_RECEIVER](createPluginResolver(plugin!!, pluginDescriptor)) -> <v22>, r(plugin) -> <v23>, magic[NOT_NULL_ASSERTION](plugin!!|<v23>) -> <v24>, r(pluginDescriptor) -> <v25>, mark(createPluginResolver(plugin!!, pluginDescriptor)), call(createPluginResolver(plugin!!, pluginDescriptor), createPluginResolver|<v22>, <v24>, <v25>) -> <v26>, v(pluginResolver), call(pluginResolver, component1|<v26>) -> <v27>, w(pluginResolver|<v27>), v(badResult2), call(badResult2, component2|<v26>) -> <v28>, w(badResult2|<v28>), mark(if (badResult2 != null) { return null to badResult2 }), r(badResult2) -> <v29>, r(null) -> <v30>, mark(badResult2 != null), call(badResult2 != null, equals|<v29>, <v30>) -> <v31>, jf(L5|<v31>), mark({ return null to badResult2 }), r(null) -> <v32>, r(badResult2) -> <v33>, mark(null to badResult2), call(null to badResult2, to|<v32>, <v33>) -> <v34>, mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L7), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, ret(*|<v34>) L1, jmp(L9), read (Unit), merge(if (badResult2 != null) { return null to badResult2 }|!<v38>) -> <v39>, mark(pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), r(pluginResolver) -> <v40>, magic[NOT_NULL_ASSERTION](pluginResolver!!|<v40>) -> <v41>, mark(puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), mark({ val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), jmp?(L10), d({ val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), r({ val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }) -> <v42>, mark(use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), call(use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }, use|<v41>, <v42>), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L48), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, jmp(error), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L49), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, jmp(error), jmp(L50), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L51), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, jmp(error), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L52), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, merge(try { val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } } finally { pluginLock?.releaseLock() }|!<v43>) -> <v44>, <END>, <ERROR>, <SINK>]
java.lang.IllegalStateException: resolveToInstruction: incorrect index 158 for label L40 in subroutine private fun verification(pluginDescriptor: PluginDescriptor,
                           ide: Ide,
                           ideDescriptor: IdeDescriptor,
                           params: VParams,
                           ideResolver: Resolver,
                           runtimeResolver: Resolver): Pair<Plugin?, VResult> {
    val (plugin: Plugin?, pluginLock: IFileLock?, badResult: VResult?) = createPlugin(pluginDescriptor, ide.version)
    if (badResult != null) {
      return null to badResult
    }
    try {
      val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor)
      if (badResult2 != null) {
        return null to badResult2
      }

      pluginResolver!!.use puse@ {
        val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options)
        val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx)

        try {
          dependenciesResolver.use {
            try {
              val checkClasses = getClassesForCheck(plugin, pluginResolver)
              val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath)

              VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) }

              val warnings = ctx.warnings +
                  (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) +
                  (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList())

              if (ctx.problems.isEmpty) {
                return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings)
              } else {
                return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings)
              }

            } catch (ie: InterruptedException) {
              throw ie
            } catch (e: Exception) {
              val message = "Failed to verify $pluginDescriptor with $ideDescriptor"
              LOG.error(message, e)
              throw RuntimeException(message, e)
            }
          }
        } finally {
          pluginLocks.forEach { it.release() }
        }

      }
    } finally {
      pluginLock?.releaseLock()
    }

  } with instructions [<START>, v(pluginDescriptor: PluginDescriptor), magic[FAKE_INITIALIZER](pluginDescriptor: PluginDescriptor) -> <v0>, w(pluginDescriptor|<v0>), v(ide: Ide), magic[FAKE_INITIALIZER](ide: Ide) -> <v1>, w(ide|<v1>), v(ideDescriptor: IdeDescriptor), magic[FAKE_INITIALIZER](ideDescriptor: IdeDescriptor) -> <v2>, w(ideDescriptor|<v2>), v(params: VParams), magic[FAKE_INITIALIZER](params: VParams) -> <v3>, w(params|<v3>), v(ideResolver: Resolver), magic[FAKE_INITIALIZER](ideResolver: Resolver) -> <v4>, w(ideResolver|<v4>), v(runtimeResolver: Resolver), magic[FAKE_INITIALIZER](runtimeResolver: Resolver) -> <v5>, w(runtimeResolver|<v5>), mark({ val (plugin: Plugin?, pluginLock: IFileLock?, badResult: VResult?) = createPlugin(pluginDescriptor, ide.version) if (badResult != null) { return null to badResult } try { val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } } finally { pluginLock?.releaseLock() } }), magic[IMPLICIT_RECEIVER](createPlugin(pluginDescriptor, ide.version)) -> <v6>, r(pluginDescriptor) -> <v7>, mark(ide.version), r(ide) -> <v8>, r(version|<v8>) -> <v9>, mark(createPlugin(pluginDescriptor, ide.version)), call(createPlugin(pluginDescriptor, ide.version), createPlugin|<v6>, <v7>, <v9>) -> <v10>, v(plugin: Plugin?), call(plugin: Plugin?, component1|<v10>) -> <v11>, w(plugin|<v11>), v(pluginLock: IFileLock?), call(pluginLock: IFileLock?, component2|<v10>) -> <v12>, w(pluginLock|<v12>), v(badResult: VResult?), call(badResult: VResult?, component3|<v10>) -> <v13>, w(badResult|<v13>), mark(if (badResult != null) { return null to badResult }), r(badResult) -> <v14>, r(null) -> <v15>, mark(badResult != null), call(badResult != null, equals|<v14>, <v15>) -> <v16>, jf(L2|<v16>), mark({ return null to badResult }), r(null) -> <v17>, r(badResult) -> <v18>, mark(null to badResult), call(null to badResult, to|<v17>, <v18>) -> <v19>, ret(*|<v19>) L1, jmp(L3), read (Unit), merge(if (badResult != null) { return null to badResult }|!<v20>) -> <v21>, mark(try { val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } } finally { pluginLock?.releaseLock() }), jmp?(L4), mark({ val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } }), magic[IMPLICIT_RECEIVER](createPluginResolver(plugin!!, pluginDescriptor)) -> <v22>, r(plugin) -> <v23>, magic[NOT_NULL_ASSERTION](plugin!!|<v23>) -> <v24>, r(pluginDescriptor) -> <v25>, mark(createPluginResolver(plugin!!, pluginDescriptor)), call(createPluginResolver(plugin!!, pluginDescriptor), createPluginResolver|<v22>, <v24>, <v25>) -> <v26>, v(pluginResolver), call(pluginResolver, component1|<v26>) -> <v27>, w(pluginResolver|<v27>), v(badResult2), call(badResult2, component2|<v26>) -> <v28>, w(badResult2|<v28>), mark(if (badResult2 != null) { return null to badResult2 }), r(badResult2) -> <v29>, r(null) -> <v30>, mark(badResult2 != null), call(badResult2 != null, equals|<v29>, <v30>) -> <v31>, jf(L5|<v31>), mark({ return null to badResult2 }), r(null) -> <v32>, r(badResult2) -> <v33>, mark(null to badResult2), call(null to badResult2, to|<v32>, <v33>) -> <v34>, mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L7), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, ret(*|<v34>) L1, jmp(L9), read (Unit), merge(if (badResult2 != null) { return null to badResult2 }|!<v38>) -> <v39>, mark(pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), r(pluginResolver) -> <v40>, magic[NOT_NULL_ASSERTION](pluginResolver!!|<v40>) -> <v41>, mark(puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), mark({ val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), jmp?(L10), d({ val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), r({ val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }) -> <v42>, mark(use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }), call(use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } }, use|<v41>, <v42>), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L48), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, jmp(error), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L49), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, jmp(error), jmp(L50), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L51), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, jmp(error), mark({ pluginLock?.releaseLock() }), mark(pluginLock?.releaseLock()), jf(L52), r(pluginLock) -> <v35>, mark(releaseLock()), magic[UNRESOLVED_CALL](releaseLock()|!<v36>, <v35>) -> <v37>, merge(try { val (pluginResolver, badResult2) = createPluginResolver(plugin!!, pluginDescriptor) if (badResult2 != null) { return null to badResult2 } pluginResolver!!.use puse@ { val ctx = VContext(plugin, pluginDescriptor, ide, ideDescriptor, params.options) val (dependenciesResolver, dependenciesGraph, cycle: List<Plugin>?, pluginLocks: List<IFileLock>) = getDependenciesResolver(ctx) try { dependenciesResolver.use { try { val checkClasses = getClassesForCheck(plugin, pluginResolver) val classLoader = createClassLoader(dependenciesResolver, ctx, ideResolver, pluginResolver, runtimeResolver, params.externalClassPath) VERIFIERS.forEach { it.verify(ctx, checkClasses, classLoader) } val warnings = ctx.warnings + (if (plugin is PluginImpl) plugin.hints.map { Warning(it) } else emptyList()) + (if (cycle != null) listOf(Warning(cycle.joinToString(separator = " -> ") { it.pluginId })) else emptyList()) if (ctx.problems.isEmpty) { return plugin to VResult.Nice(ctx.pluginDescriptor, ctx.ideDescriptor, warnings) } else { return plugin to VResult.Problems(ctx.pluginDescriptor, ctx.ideDescriptor, ctx.problems, dependenciesGraph, warnings) } } catch (ie: InterruptedException) { throw ie } catch (e: Exception) { val message = "Failed to verify $pluginDescriptor with $ideDescriptor" LOG.error(message, e) throw RuntimeException(message, e) } } } finally { pluginLocks.forEach { it.release() } } } } finally { pluginLock?.releaseLock() }|!<v43>) -> <v44>, <END>, <ERROR>, <SINK>]
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl$PseudocodeLabel.resolveToInstruction(PseudocodeImpl.kt:63)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.getJumpTarget(PseudocodeImpl.kt:367)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.access$getJumpTarget(PseudocodeImpl.kt:42)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl$processInstruction$1.visitConditionalJump(PseudocodeImpl.kt:300)
	at org.jetbrains.kotlin.cfg.pseudocode.instructions.jumps.ConditionalJumpInstruction.accept(ConditionalJumpInstruction.kt:57)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.processInstruction(PseudocodeImpl.kt:281)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.postProcess(PseudocodeImpl.kt:257)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl$processInstruction$1.visitLocalFunctionDeclarationInstruction(PseudocodeImpl.kt:315)
	at org.jetbrains.kotlin.cfg.pseudocode.instructions.special.LocalFunctionDeclarationInstruction.accept(LocalFunctionDeclarationInstruction.kt:50)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.processInstruction(PseudocodeImpl.kt:281)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.postProcess(PseudocodeImpl.kt:257)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl$processInstruction$1.visitLocalFunctionDeclarationInstruction(PseudocodeImpl.kt:315)
	at org.jetbrains.kotlin.cfg.pseudocode.instructions.special.LocalFunctionDeclarationInstruction.accept(LocalFunctionDeclarationInstruction.kt:50)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.processInstruction(PseudocodeImpl.kt:281)
	at org.jetbrains.kotlin.cfg.pseudocode.PseudocodeImpl.postProcess(PseudocodeImpl.kt:257)
	at org.jetbrains.kotlin.cfg.ControlFlowProcessor.generatePseudocode(ControlFlowProcessor.kt:65)
	at org.jetbrains.kotlin.cfg.ControlFlowInformationProvider.<init>(ControlFlowInformationProvider.java:94)
	at org.jetbrains.kotlin.idea.project.ResolveElementCache.performElementAdditionalResolve(ResolveElementCache.kt:326)
	at org.jetbrains.kotlin.idea.project.ResolveElementCache.getElementAdditionalResolve(ResolveElementCache.kt:137)
	at org.jetbrains.kotlin.idea.project.ResolveElementCache.resolveFunctionBody(ResolveElementCache.kt:116)
	at org.jetbrains.kotlin.resolve.BodyResolver.resolveFunctionBodies(BodyResolver.java:760)
	at org.jetbrains.kotlin.resolve.BodyResolver.resolveBehaviorDeclarationBodies(BodyResolver.java:108)
	at org.jetbrains.kotlin.resolve.BodyResolver.resolveBodies(BodyResolver.java:230)
	at org.jetbrains.kotlin.resolve.LazyTopDownAnalyzer.analyzeDeclarations(LazyTopDownAnalyzer.kt:191)
	at org.jetbrains.kotlin.resolve.LazyTopDownAnalyzerForTopLevel.analyzeDeclarations(LazyTopDownAnalyzerForTopLevel.java:74)
	at org.jetbrains.kotlin.idea.caches.resolve.KotlinResolveDataProvider.analyze(KotlinResolveCache.kt:178)
	at org.jetbrains.kotlin.idea.caches.resolve.PerFileAnalysisCache.analyze(KotlinResolveCache.kt:94)
	at org.jetbrains.kotlin.idea.caches.resolve.PerFileAnalysisCache.getAnalysisResults(KotlinResolveCache.kt:79)
	at org.jetbrains.kotlin.idea.caches.resolve.ProjectResolutionFacade.getAnalysisResultsForElements(ProjectResolutionFacade.kt:81)
	at org.jetbrains.kotlin.idea.caches.resolve.ResolutionFacadeImpl.analyzeFullyAndGetResult(ProjectResolutionFacade.kt:113)
	at org.jetbrains.kotlin.idea.caches.resolve.ResolutionUtils.analyzeFullyAndGetResult(resolutionApi.kt:77)
	at org.jetbrains.kotlin.idea.highlighter.KotlinPsiChecker.annotate(KotlinPsiChecker.kt:63)
	at com.intellij.codeInsight.daemon.impl.DefaultHighlightVisitor.a(DefaultHighlightVisitor.java:139)
	at com.intellij.codeInsight.daemon.impl.DefaultHighlightVisitor.visit(DefaultHighlightVisitor.java:102)
	at com.intellij.codeInsight.daemon.impl.GeneralHighlightingPass.a(GeneralHighlightingPass.java:338)
	at com.intellij.codeInsight.daemon.impl.GeneralHighlightingPass.a(GeneralHighlightingPass.java:273)
	at com.intellij.codeInsight.daemon.impl.GeneralHighlightingPass.a(GeneralHighlightingPass.java:297)
	at com.intellij.codeInsight.daemon.impl.GeneralHighlightingPass.a(GeneralHighlightingPass.java:300)
	at com.intellij.codeInsight.daemon.impl.DefaultHighlightVisitor.analyze(DefaultHighlightVisitor.java:86)
	at com.intellij.codeInsight.daemon.impl.GeneralHighlightingPass.a(GeneralHighlightingPass.java:300)
	at com.intellij.codeInsight.daemon.impl.GeneralHighlightingPass.a(GeneralHighlightingPass.java:272)
	at com.intellij.codeInsight.daemon.impl.GeneralHighlightingPass.collectInformationWithProgress(GeneralHighlightingPass.java:211)
	at com.intellij.codeInsight.daemon.impl.ProgressableTextEditorHighlightingPass.doCollectInformation(ProgressableTextEditorHighlightingPass.java:82)
	at com.intellij.codeHighlighting.TextEditorHighlightingPass.collectInformation(TextEditorHighlightingPass.java:70)
	at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.a(PassExecutorService.java:431)
	at com.intellij.openapi.application.impl.ApplicationImpl.tryRunReadAction(ApplicationImpl.java:1038)
	at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.b(PassExecutorService.java:424)
	at com.intellij.openapi.progress.impl.CoreProgressManager.a(CoreProgressManager.java:568)
	at com.intellij.openapi.progress.impl.CoreProgressManager.executeProcessUnderProgress(CoreProgressManager.java:519)
	at com.intellij.openapi.progress.impl.ProgressManagerImpl.executeProcessUnderProgress(ProgressManagerImpl.java:54)
	at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.c(PassExecutorService.java:423)
	at com.intellij.codeInsight.daemon.impl.PassExecutorService$ScheduledPass.run(PassExecutorService.java:403)
	at com.intellij.concurrency.JobLauncherImpl$VoidForkJoinTask$1.exec(JobLauncherImpl.java:154)
	at java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:289)
	at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1056)
	at java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1692)
	at java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:157){cut}

There is a project in the attachments