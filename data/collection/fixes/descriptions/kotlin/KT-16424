Given the following Java class and Kotlin code:

```java
public class TestClass {
    public <T> T set(@Nullable String key, @Nullable T t) {
        return t;
    }
}
```

```kotlin
fun main(args: Array<String>) {
    run()
}

fun run() {
    val testClass = TestClass()
    testClass.set("test", null)
    println("Test")
}
```

Kotlin generates broken bytecode for the `testClass.set("test", null)` call. The compiler and IDE will mark the following line `println("Test")` as unreachable code. At runtime, it will always throw a NPE. The generated bytecode looks like this:

```
// access flags 0x19
  public final static run()V
   L0
    LINENUMBER 8 L0
    NEW net/minecrell/test/TestClass
    DUP
    INVOKESPECIAL net/minecrell/test/TestClass.<init> ()V
    ASTORE 0
   L1
    LINENUMBER 9 L1
    ALOAD 0
    LDC "test"
    ACONST_NULL
    INVOKEVIRTUAL net/minecrell/test/TestClass.set (Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;
    ACONST_NULL
    ATHROW
   L2
   L3
   L4
   L5
   L6
   L7
    LOCALVARIABLE testClass Lnet/minecrell/test/TestClass; L1 L7 0
    MAXSTACK = 3
    MAXLOCALS = 2
```

Decompiled:

```java
   public static final void run() {
      TestClass testClass = new TestClass();
      testClass.set("test", (Object)null);
      throw null;
   }
```

I'm unsure why it generates a `throw null` in there, but the method should be callable without problems. (You could argue the return value should be `@Nullable` but it should work nonetheless.)