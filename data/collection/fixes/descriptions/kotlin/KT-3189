{code}
fun main(args:Array<String>) {
  val ok = Good<Int>({ it })  
  println("Ok:  ${ ok.test(1) } = 1")
  
  val bad = Bad<Int>({ it })
  println("Bad: ${ bad.test(1) } = AssertionError :( ")
}
  
class Good<T>(val a:(T)->T) {
  
    fun test(  p1: T):T = p1
  
    // Does not harm
    fun invoke(p1: T):T = throw AssertionError("This function must not be called")
}

class Bad<T>(val a:(T)->T) {
  
    fun test(  p1: T):T = a(p1) // this is the only difference from Good
  
    // Everything works perfecly if the following line is commented out
    fun invoke(p1: T):T = throw AssertionError("This function must not be called")
}
{code}

I guess, the root cause of the problem is a class function *test*, which internally calls a closure (jet.Function1). Instead of calling a.invoke, generated bytecode calls this.invoke, but only if method is present:

{code}
  public final test(Ljava/lang/Object;)Ljava/lang/Object;
  @Ljet/runtime/typeinfo/JetMethod;(flags=16, returnType="TT;")
    @Ljet/runtime/typeinfo/JetValueParameter;(name="p1", type="TT;") // parameter 0
   L0
   L1
    LINENUMBER 26 L1
    ALOAD 0
    ALOAD 1
    INVOKEVIRTUAL Bad.invoke (Ljava/lang/Object;)Ljava/lang/Object;  // Wrong function is called here!!
    ARETURN
   L2
    LOCALVARIABLE this LBad; L0 L2 0
    LOCALVARIABLE p1 Ljava/lang/Object; L0 L2 1
    MAXSTACK = -1
    MAXLOCALS = -1
{code}

If class own function invoke is not present, bytecode is correct:

{code}
  public final test(Ljava/lang/Object;)Ljava/lang/Object;
  @Ljet/runtime/typeinfo/JetMethod;(flags=16, returnType="TT;")
    @Ljet/runtime/typeinfo/JetValueParameter;(name="p1", type="TT;") // parameter 0
   L0
   L1
    LINENUMBER 26 L1
    ALOAD 0
    GETFIELD Bad.a : Ljet/Function1;  // actually using parameter 'a'
    ALOAD 1
    INVOKEVIRTUAL jet/Function1.invoke (Ljava/lang/Object;)Ljava/lang/Object;   // Correct!
    ARETURN
   L2
    LOCALVARIABLE this LBad; L0 L2 0
    LOCALVARIABLE p1 Ljava/lang/Object; L0 L2 1
    MAXSTACK = -1
    MAXLOCALS = -1
{code}