# Classification

* Change in typechecking of Java methods
* Motivation types:
    * Nullability unsafe Java method usages
* Impact types:
    * Some code that used to compile won't compile anymore
    * There were cases when such code worked with no problems
* Detection and Migration modes:
    * Gradual migration is expected: at first there will be warnings on the code that won't compile in the next version
    * Some automated migration is possible

# Background

Combination of Java `@NotNull` annotation and Kotlin generic parameter with nullable upper bound doesn't work correctly:
```
// FILE: SLRUMap.java

import org.jetbrains.annotations.NotNull;

public interface SLRUMap<V> {
    void takeV(@NotNull V value);
}

// FILE: main.kt

fun SLRUMap<String?>.getOrPutString(value: String?) {
    takeV(value) // Error reported, because nullable value is used for not-nullable type parameter
}

fun <E> SLRUMap<E>.getOrPut(value: E) {
    takeV(value) // No errors, but may fail with NPE 
}
```

This code should be disallowed since if we call `getOrPut` with `null` value on an instance of `SLRUMap<String?>` type, it may fail with NullPointerException in implementation of `SLRUMap`

# Existing behavior

## Code example
```
// FILE: SLRUMap.java

import org.jetbrains.annotations.NotNull;
import java.util.List;

public interface SLRUMap<V> {
    void takeV(@NotNull V value);
    <E> void takeE(@NotNull E value);

    void takeVList(@NotNull List<@NotNull V> value);
    <E> void takeEList(@NotNull List<@NotNull E> value);
}

// FILE: main.kt

fun <E> SLRUMap<E>.getOrPut(value: E, l: List<E>) {
    takeV(value) // No error, but E is nullable while expected type is not
    takeVList(l) // No error, but given list elements are nullable while in expected type List elements are not nullable
    takeE(value) // No error, but E is nullable while expected type is not
    takeEList(l) // No error, but given list elements are nullable while in expected type List elements are not nullable
}
```

## What's wrong with it

Currently, that code is compiled successfully without any warnings while implementation clearly expects it's not null.
Also, there might be runtime checks on the entrance of the method automatically generated by [intellij instrumenter](https://github.com/JetBrains/gradle-intellij-plugin).


Besides that, the behavior is not consistent with a case when an argument for `takeV` is not a Kotlin generic parameter
```
fun SLRUMap<String?>.getOrPutString(value: String?, l: List<String?>) {
    takeV(value) // TYPE_MISMATCH error
    takeVList(l) // TYPE_MISMATCH error

    takeE(value) // TYPE_MISMATCH error
    takeEList(l) // TYPE_MISMATCH error
}
```

These cases (`getOrPut` and `getOrPutString`) should obviously work consistently because the contents of the latter one might be simply replaced with a call `this.getOrPut(value, l)` that is safe & sound, while the definition `getOrPut` is not.

## Detailed explanation of why and how this happens

This is just an implementation bug caused by a combination of two factors:
- a very special Java type `@NotNull V` that is not fully expressible in Kotlin because after substitution `V -> String?` should still remain not-nullable unlike the situation if `V` was a common Kotlin type based on a generic parameter
- For a `value` with a type `E` the compiler ignored the fact that `E` has nullable implicit upper bound `Any?` and thus may contain a nullable value.

## Affected versions: when did the problem appear first? 

This problem exists since Kotlin 1.0.

# Proposed changes

The proposal is to prohibit using values of nullable generic types (`E`) as arguments for `@NotNull` annotated generic-bases parameters (`@NotNull V`).
Namely, subtyping the condition of the form `E <: @NotNull V` should not be true.

# Assumed fix for the user
Adding not nullable upper bound to `E` parameter. The following piece of code should be compiled successfully:
```
fun <E : Any> SLRUMap<E>.getOrPut(value: E, l: List<E>) {
    takeV(value)
    takeVList(l) 

    takeE(value) 
    takeEList(l) 
}
```

# Impact

New compilation errors are possible if there were incorrect nullability usages like from the sample above

# Migration plan

- Report warnings in 1.4.x on each incorrect calls from the sample above
- Report TYPE_MISMATCH errors since 1.5