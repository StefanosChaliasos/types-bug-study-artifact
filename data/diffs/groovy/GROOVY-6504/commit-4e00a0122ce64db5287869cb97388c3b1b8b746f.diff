diff --git a/src/main/org/codehaus/groovy/ast/GenericsType.java b/src/main/org/codehaus/groovy/ast/GenericsType.java
index 45835eb1f4..e151c5b841 100644
--- a/src/main/org/codehaus/groovy/ast/GenericsType.java
+++ b/src/main/org/codehaus/groovy/ast/GenericsType.java
@@ -69,10 +69,14 @@ public class GenericsType extends ASTNode {
         if (placeholder) visited.add(name);
         String ret = wildcard?"?":((type == null || placeholder) ? name : genericsBounds(type, visited));
         if (upperBounds != null) {
-            ret += " extends ";
-            for (int i = 0; i < upperBounds.length; i++) {
-                ret += genericsBounds(upperBounds[i], visited);
-                if (i + 1 < upperBounds.length) ret += " & ";
+            if (placeholder && upperBounds.length==1 && !upperBounds[0].isGenericsPlaceHolder() && upperBounds[0].getName().equals("java.lang.Object")) {
+                // T extends Object should just be printed as T
+            } else {
+                ret += " extends ";
+                for (int i = 0; i < upperBounds.length; i++) {
+                    ret += genericsBounds(upperBounds[i], visited);
+                    if (i + 1 < upperBounds.length) ret += " & ";
+                }
             }
         } else if (lowerBound != null) {
             ret += " super " + genericsBounds(lowerBound, visited);
@@ -297,7 +301,7 @@ public class GenericsType extends ASTNode {
          */
         private boolean compareGenericsWithBound(final ClassNode classNode, final ClassNode bound) {
             if (classNode==null) return false;
-            if (!bound.isUsingGenerics()) {
+            if (!bound.isUsingGenerics() || (classNode.getGenericsTypes()==null && classNode.redirect().getGenericsTypes()!=null)) {
                 // if the bound is not using generics, there's nothing to compare with
                 return true;
             }
diff --git a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
index a56886527c..2400f75a9f 100644
--- a/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
+++ b/src/main/org/codehaus/groovy/ast/tools/GenericsUtils.java
@@ -160,6 +160,9 @@ public class GenericsUtils {
      * @return a parameterized interface class node
      */
     public static ClassNode parameterizeType(final ClassNode hint, final ClassNode target) {
+        if (hint.isArray() && target.isArray()) {
+            return parameterizeType(hint.getComponentType(), target.getComponentType()).makeArray();
+        }
         ClassNode interfaceFromClassNode = null;
         if (hint.equals(target)) interfaceFromClassNode = hint;
         if (ClassHelper.OBJECT_TYPE.equals(target) && target.isUsingGenerics() && target.getGenericsTypes()!=null
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
index 8d48d97812..779d268c8b 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingSupport.java
@@ -19,6 +19,7 @@ package org.codehaus.groovy.transform.stc;
 import org.codehaus.groovy.GroovyBugError;
 import org.codehaus.groovy.ast.*;
 import org.codehaus.groovy.ast.expr.*;
+import org.codehaus.groovy.ast.stmt.EmptyStatement;
 import org.codehaus.groovy.ast.stmt.ReturnStatement;
 import org.codehaus.groovy.ast.tools.GenericsUtils;
 import org.codehaus.groovy.ast.tools.WideningCategories;
@@ -787,7 +788,7 @@ public abstract class StaticTypeCheckingSupport {
     }
 
     static int getPrimitiveDistance(ClassNode primA, ClassNode primB) {
-        return Math.abs(NUMBER_TYPES.get(primA)-NUMBER_TYPES.get(primB));
+        return Math.abs(NUMBER_TYPES.get(primA) - NUMBER_TYPES.get(primB));
     }
 
     static int getDistance(final ClassNode receiver, final ClassNode compare) {
@@ -874,6 +875,7 @@ public abstract class StaticTypeCheckingSupport {
     public static List<MethodNode> findDGMMethodsByNameAndArguments(final ClassLoader loader, final ClassNode receiver, final String name, final ClassNode[] args, final List<MethodNode> methods) {
         final List<MethodNode> chosen;
         methods.addAll(findDGMMethodsForClassNode(loader, receiver, name));
+        if (methods.isEmpty()) return methods;
 
         chosen = chooseBestMethod(receiver, methods, args);
         // specifically for DGM-like methods, we may have a generic type as the first argument of the DGM method
@@ -882,8 +884,14 @@ public abstract class StaticTypeCheckingSupport {
         Iterator<MethodNode> iterator = chosen.iterator();
         while (iterator.hasNext()) {
             ExtensionMethodNode emn = (ExtensionMethodNode) iterator.next();
-            MethodNode dgmMethod = emn.getExtensionMethodNode(); // this is the method from DGM
-            GenericsType[] methodGenericTypes = dgmMethod.getGenericsTypes();
+            /*if (!typeCheckMethodsWithGenerics(
+                    receiver,
+                    args,
+                    emn
+            )) {
+                iterator.remove();
+            }*/
+            /*GenericsType[] methodGenericTypes = dgmMethod.getGenericsTypes();
             if (methodGenericTypes !=null && methodGenericTypes.length>0) {
                 Parameter[] parameters = dgmMethod.getParameters();
                 ClassNode dgmOwnerType = parameters[0].getOriginType();
@@ -962,7 +970,7 @@ public abstract class StaticTypeCheckingSupport {
                         }
                     }
                 }
-            }
+            }*/
         }
         return chosen;
     }
@@ -980,11 +988,21 @@ public abstract class StaticTypeCheckingSupport {
         if (methods.isEmpty()) return Collections.emptyList();
         List<MethodNode> bestChoices = new LinkedList<MethodNode>();
         int bestDist = Integer.MAX_VALUE;
-        ClassNode actualReceiver;
         Collection<MethodNode> choicesLeft = removeCovariants(methods);
-        for (MethodNode m : choicesLeft) {
-            final ClassNode declaringClass = m.getDeclaringClass();
-            actualReceiver = receiver!=null?receiver: declaringClass;
+        for (MethodNode candidateNode : choicesLeft) {
+            ClassNode declaringClass = candidateNode.getDeclaringClass();
+            ClassNode actualReceiver = receiver!=null?receiver: declaringClass;
+            MethodNode safeNode = candidateNode;
+            ClassNode[] safeArgs = args;
+            if (candidateNode instanceof ExtensionMethodNode) {
+                safeArgs = new ClassNode[args.length+1];
+                System.arraycopy(args, 0, safeArgs, 1, args.length);
+                safeArgs[0] = receiver;
+                safeNode = ((ExtensionMethodNode) candidateNode).getExtensionMethodNode();
+                declaringClass = safeNode.getDeclaringClass();
+                actualReceiver = declaringClass;
+            }
+
             // todo : corner case
             /*
                 class B extends A {}
@@ -996,17 +1014,17 @@ public abstract class StaticTypeCheckingSupport {
                 Person p = foo(b)
              */
 
-            Parameter[] params = parameterizeArguments(actualReceiver, m);
-            if (params.length == args.length) {
-                int allPMatch = allParametersAndArgumentsMatch(params, args);
+            Parameter[] params = parameterizeArguments(actualReceiver, safeNode);
+            if (params.length == safeArgs.length) {
+                int allPMatch = allParametersAndArgumentsMatch(params, safeArgs);
                 boolean firstParamMatches = true;
                 // check first parameters
-                if (args.length > 0) {
+                if (safeArgs.length > 0) {
                     Parameter[] firstParams = new Parameter[params.length - 1];
                     System.arraycopy(params, 0, firstParams, 0, firstParams.length);
-                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, args) >= 0;
+                    firstParamMatches = allParametersAndArgumentsMatch(firstParams, safeArgs) >= 0;
                 }
-                int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, args):-1;
+                int lastArgMatch = isVargs(params) && firstParamMatches?lastArgMatchesVarg(params, safeArgs):-1;
                 if (lastArgMatch>=0) {
                     lastArgMatch += 256-params.length; // ensure exact matches are preferred over vargs
                 }
@@ -1014,19 +1032,19 @@ public abstract class StaticTypeCheckingSupport {
                 if (dist>=0 && !actualReceiver.equals(declaringClass)) dist+=getDistance(actualReceiver, declaringClass);
                 if (dist>=0 && dist<bestDist) {
                     bestChoices.clear();
-                    bestChoices.add(m);
+                    bestChoices.add(candidateNode);
                     bestDist = dist;
                 } else if (dist>=0 && dist==bestDist) {
-                    bestChoices.add(m);
+                    bestChoices.add(candidateNode);
                 }
             } else if (isVargs(params)) {
                 boolean firstParamMatches = true;
                 int dist = -1;
                 // check first parameters
-                if (args.length > 0) {
+                if (safeArgs.length > 0) {
                     Parameter[] firstParams = new Parameter[params.length - 1];
                     System.arraycopy(params, 0, firstParams, 0, firstParams.length);
-                    dist = allParametersAndArgumentsMatch(firstParams, args);
+                    dist = allParametersAndArgumentsMatch(firstParams, safeArgs);
                     firstParamMatches =  dist >= 0;
                 } else {
                     dist = 0;
@@ -1034,32 +1052,32 @@ public abstract class StaticTypeCheckingSupport {
                 if (firstParamMatches) {
                     // there are three case for vargs
                     // (1) varg part is left out
-                    if (params.length == args.length + 1) {
+                    if (params.length == safeArgs.length + 1) {
                         if (dist>=0) {
                             dist += 256-params.length; // ensure exact matches are preferred over vargs
                         }
                         if (bestDist > 1+dist) {
                             bestChoices.clear();
-                            bestChoices.add(m);
+                            bestChoices.add(candidateNode);
                             bestDist = 1+dist; // 1+dist to discriminate foo(Object,String) vs foo(Object,String, Object...)
                         }
                     } else {
                         // (2) last argument is put in the vargs array
                         //      that case is handled above already
                         // (3) there is more than one argument for the vargs array
-                        dist += excessArgumentsMatchesVargsParameter(params, args);
+                        dist += excessArgumentsMatchesVargsParameter(params, safeArgs);
                         if (dist >= 0 && !actualReceiver.equals(declaringClass)) dist+=getDistance(actualReceiver, declaringClass);
                         // varargs methods must not be preferred to methods without varargs
                         // for example :
                         // int sum(int x) should be preferred to int sum(int x, int... y)
                         dist+=256-params.length;
-                        if (params.length < args.length && dist >= 0) {
+                        if (params.length < safeArgs.length && dist >= 0) {
                             if (dist >= 0 && dist < bestDist) {
                                 bestChoices.clear();
-                                bestChoices.add(m);
+                                bestChoices.add(candidateNode);
                                 bestDist = dist;
                             } else if (dist >= 0 && dist == bestDist) {
-                                bestChoices.add(m);
+                                bestChoices.add(candidateNode);
                             }
                         }
                     }
@@ -1129,17 +1147,9 @@ public abstract class StaticTypeCheckingSupport {
      * @return the parameterized arguments
      */
     public static Parameter[] parameterizeArguments(final ClassNode receiver, final MethodNode m) {
-        MethodNode mn = m;
-        ClassNode actualReceiver = receiver;
-        /*if (m instanceof ExtensionMethodNode) {
-            ExtensionMethodNode emn = (ExtensionMethodNode) m;
-            mn = emn.getExtensionMethodNode();
-            actualReceiver = emn.getDeclaringClass();
-        }*/
         List<GenericsType> redirectTypes = new ArrayList<GenericsType>();
-//        if (mn.getGenericsTypes()!=null) Collections.addAll(redirectTypes,mn.getGenericsTypes());
-        if (actualReceiver.redirect().getGenericsTypes()!=null) {
-            Collections.addAll(redirectTypes,actualReceiver.redirect().getGenericsTypes());
+        if (receiver.redirect().getGenericsTypes()!=null) {
+            Collections.addAll(redirectTypes, receiver.redirect().getGenericsTypes());
         }
 
         if (redirectTypes.isEmpty()) {
@@ -1147,53 +1157,294 @@ public abstract class StaticTypeCheckingSupport {
         }
         GenericsType[] redirectReceiverTypes = redirectTypes.toArray(new GenericsType[redirectTypes.size()]);
 
-        Parameter[] methodParameters = mn.getParameters();
+        Parameter[] methodParameters = m.getParameters();
         Parameter[] params = new Parameter[methodParameters.length];
-        GenericsType[] receiverParameterizedTypes = actualReceiver.getGenericsTypes();
+        GenericsType[] receiverParameterizedTypes = receiver.getGenericsTypes();
         if (receiverParameterizedTypes==null) {
             receiverParameterizedTypes = redirectReceiverTypes;
         }
         for (int i = 0; i < methodParameters.length; i++) {
             Parameter methodParameter = methodParameters[i];
             ClassNode paramType = methodParameter.getType();
-            if (paramType.isUsingGenerics()) {
-                GenericsType[] alignmentTypes = paramType.getGenericsTypes();
-                GenericsType[] genericsTypes = GenericsUtils.alignGenericTypes(redirectReceiverTypes, receiverParameterizedTypes, alignmentTypes);
-                if (genericsTypes.length==1) {
-                    ClassNode parameterizedCN;
-                    if (paramType.equals(OBJECT_TYPE)) {
-                        parameterizedCN = genericsTypes[0].getType();
-                    } else {
-                        parameterizedCN= paramType.getPlainNodeReference();
-                        parameterizedCN.setGenericsTypes(genericsTypes);
-                    }
-                    params[i] = new Parameter(
-                            parameterizedCN,
-                            methodParameter.getName()
-                    );
+            params[i] = buildParameter(redirectReceiverTypes, receiverParameterizedTypes, methodParameter, paramType);;
+        }
+        return params;
+    }
+
+    private static Parameter buildParameter(final GenericsType[] redirectReceiverTypes, final GenericsType[] receiverParameterizedTypes, final Parameter methodParameter, final ClassNode paramType) {
+        if (paramType.isArray()) {
+            Parameter component = buildParameter(redirectReceiverTypes, receiverParameterizedTypes, methodParameter, paramType.getComponentType());
+            return new Parameter(component.getType().makeArray(), component.getName());
+        }
+        final Parameter newParam;
+        if (paramType.isUsingGenerics()) {
+            GenericsType[] alignmentTypes = paramType.getGenericsTypes();
+            GenericsType[] genericsTypes = GenericsUtils.alignGenericTypes(redirectReceiverTypes, receiverParameterizedTypes, alignmentTypes);
+            if (genericsTypes.length==1) {
+                ClassNode parameterizedCN;
+                if (paramType.equals(OBJECT_TYPE)) {
+                    parameterizedCN = genericsTypes[0].getType();
                 } else {
-                    params[i] = methodParameter;
+                    parameterizedCN= paramType.getPlainNodeReference();
+                    parameterizedCN.setGenericsTypes(genericsTypes);
                 }
+                newParam = new Parameter(
+                        parameterizedCN,
+                        methodParameter.getName()
+                );
             } else {
-                params[i] = methodParameter;
+                newParam = methodParameter;
             }
+        } else {
+            newParam = methodParameter;
         }
-        /*if (m instanceof ExtensionMethodNode) {
-            // the parameter array we're using is the one from the extension
-            // but we want to return an array for the regular method
-            Parameter[] result = new Parameter[params.length-1];
-            // 0 is the receiver
-            // 1..n are what we want to return
-            System.arraycopy(params, 1, result, 0, result.length);
-            return result;
-        }*/
-        return params;
+        return newParam;
     }
 
     static boolean isUsingGenericsOrIsArrayUsingGenerics(ClassNode cn) {
         return (cn.isUsingGenerics() && cn.getGenericsTypes()!=null) || cn.isArray() && cn.getComponentType().isUsingGenerics();
     }
 
+    /**
+     * Given a generics type representing SomeClass&lt;T,V&gt; and a resolved placeholder map, returns a new generics type
+     * for which placeholders are resolved recursively.
+     */
+    protected static GenericsType fullyResolve(GenericsType gt, Map<String, GenericsType> placeholders) {
+        GenericsType fromMap = placeholders.get(gt.getName());
+        if (gt.isPlaceholder() && fromMap!=null) {
+            gt = fromMap;
+        }
+
+        ClassNode type = fullyResolveType(gt.getType(), placeholders);
+        ClassNode lowerBound = gt.getLowerBound();
+        if (lowerBound != null) lowerBound = fullyResolveType(lowerBound, placeholders);
+        ClassNode[] upperBounds = gt.getUpperBounds();
+        if (upperBounds != null) {
+            ClassNode[] copy = new ClassNode[upperBounds.length];
+            for (int i = 0, upperBoundsLength = upperBounds.length; i < upperBoundsLength; i++) {
+                final ClassNode upperBound = upperBounds[i];
+                copy[i] = fullyResolveType(upperBound, placeholders);
+            }
+            upperBounds = copy;
+        }
+        GenericsType genericsType = new GenericsType(type, upperBounds, lowerBound);
+        genericsType.setWildcard(gt.isWildcard());
+        return genericsType;
+    }
+
+    protected static ClassNode fullyResolveType(final ClassNode type, final Map<String, GenericsType> placeholders) {
+        if (type.isUsingGenerics() && !type.isGenericsPlaceHolder()) {
+            GenericsType[] gts = type.getGenericsTypes();
+            if (gts != null) {
+                GenericsType[] copy = new GenericsType[gts.length];
+                for (int i = 0; i < gts.length; i++) {
+                    GenericsType genericsType = gts[i];
+                    if (genericsType.isPlaceholder() && placeholders.containsKey(genericsType.getName())) {
+                        copy[i] = placeholders.get(genericsType.getName());
+                    } else {
+                        copy[i] = fullyResolve(genericsType, placeholders);
+                    }
+                }
+                gts = copy;
+            }
+            ClassNode result = type.getPlainNodeReference();
+            result.setGenericsTypes(gts);
+            return result;
+        } else if (type.isUsingGenerics() && OBJECT_TYPE.equals(type) && type.getGenericsTypes() != null) {
+            // Object<T>
+            GenericsType genericsType = placeholders.get(type.getGenericsTypes()[0].getName());
+            if (genericsType != null) {
+                return genericsType.getType();
+            }
+        } else if (type.isArray()) {
+            return fullyResolveType(type.getComponentType(), placeholders).makeArray();
+        }
+        return type;
+    }
+
+    /**
+     * Checks that the parameterized generics of an argument are compatible with the generics of the parameter.
+     *
+     * @param parameterType the parameter type of a method
+     * @param argumentType  the type of the argument passed to the method
+     */
+    protected static boolean typeCheckMethodArgumentWithGenerics(ClassNode parameterType, ClassNode argumentType, boolean lastArg) {
+        if (UNKNOWN_PARAMETER_TYPE == argumentType) {
+            // called with null
+            return true;
+        }
+        if (!isAssignableTo(argumentType, parameterType) && !lastArg) {
+            // incompatible assignment
+            return false;
+        }
+        if (!isAssignableTo(argumentType, parameterType) && lastArg) {
+            if (parameterType.isArray()) {
+                if (!isAssignableTo(argumentType, parameterType.getComponentType())) {
+                    return false;
+                }
+            }
+        }
+        if (parameterType.isUsingGenerics() && argumentType.isUsingGenerics()) {
+            GenericsType gt = GenericsUtils.buildWildcardType(parameterType);
+            if (!gt.isCompatibleWith(argumentType)) {
+                return false;
+            }
+        } else if (parameterType.isArray() && argumentType.isArray()) {
+            // verify component type
+            return typeCheckMethodArgumentWithGenerics(parameterType.getComponentType(), argumentType.getComponentType(), lastArg);
+        } else if (lastArg && parameterType.isArray()) {
+            // verify component type, but if we reach that point, the only possibility is that the argument is
+            // the last one of the call, so we're in the cast of a vargs call
+            // (otherwise, we face a type checker bug)
+            return typeCheckMethodArgumentWithGenerics(parameterType.getComponentType(), argumentType, lastArg);
+        }
+        return true;
+    }
+
+    protected static boolean typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod) {
+        if (CLASS_Type.equals(receiver)
+                && receiver.isUsingGenerics()
+                && candidateMethod.getDeclaringClass() != receiver
+                && !(candidateMethod instanceof ExtensionMethodNode)) {
+            return typeCheckMethodsWithGenerics(receiver.getGenericsTypes()[0].getType(), arguments, candidateMethod);
+        }
+        boolean failure = false;
+        // both candidate method and receiver have generic information so a check is possible
+        Parameter[] parameters = candidateMethod.getParameters();
+        GenericsType[] genericsTypes = candidateMethod.getGenericsTypes();
+        boolean methodUsesGenerics = (genericsTypes != null && genericsTypes.length > 0);
+        boolean isExtensionMethod = candidateMethod instanceof ExtensionMethodNode;
+        if (isExtensionMethod && methodUsesGenerics) {
+            ClassNode[] dgmArgs = new ClassNode[arguments.length + 1];
+            dgmArgs[0] = receiver;
+            System.arraycopy(arguments, 0, dgmArgs, 1, arguments.length);
+            MethodNode extensionMethodNode = ((ExtensionMethodNode) candidateMethod).getExtensionMethodNode();
+            return typeCheckMethodsWithGenerics(extensionMethodNode.getDeclaringClass(), dgmArgs, extensionMethodNode);
+
+
+        }
+        Map<String, GenericsType> classGTs = GenericsUtils.extractPlaceholders(receiver);
+        if (parameters.length > arguments.length || parameters.length==0) {
+            // this is a limitation that must be removed in a future version
+            // we cannot check generic type arguments if there are default parameters!
+            return true;
+        }
+        Map<String, ClassNode> resolvedMethodGenerics = new HashMap<String, ClassNode>();
+        final GenericsType[] methodNodeGenericsTypes = candidateMethod.getGenericsTypes();
+        final boolean shouldCheckMethodGenericTypes = methodNodeGenericsTypes!=null && methodNodeGenericsTypes.length>0;
+        for (int i = 0; i < arguments.length; i++) {
+            int pindex = Math.min(i, parameters.length - 1);
+            ClassNode type = parameters[pindex].getType();
+            type = fullyResolveType(type, classGTs);
+            failure |= !typeCheckMethodArgumentWithGenerics(type, arguments[i], i >= parameters.length - 1);
+            if (shouldCheckMethodGenericTypes && !failure) {
+                // GROOVY-5692
+                // for example: public <T> foo(T arg0, List<T> arg1)
+                // we must check that T for arg0 and arg1 are the same
+                // so that if you call foo(String, List<Integer>) the compiler fails
+
+                // For that, we store the information for each argument, and for a new argument, we will
+                // check that is is the same as the previous one
+                while (type.isArray()) {
+                    type = type.getComponentType();
+                }
+                GenericsType[] typeGenericsTypes = type.getGenericsTypes();
+                if (type.isUsingGenerics() && typeGenericsTypes !=null) {
+                    for (int gtIndex = 0, typeGenericsTypesLength = typeGenericsTypes.length; gtIndex < typeGenericsTypesLength; gtIndex++) {
+                        final GenericsType typeGenericsType = typeGenericsTypes[gtIndex];
+                        if (typeGenericsType.isPlaceholder()) {
+                            for (GenericsType methodNodeGenericsType : methodNodeGenericsTypes) {
+                                String placeholderName = methodNodeGenericsType.getName();
+                                if (methodNodeGenericsType.isPlaceholder() && placeholderName.equals(typeGenericsType.getName())) {
+                                    // match!
+                                    ClassNode argument = arguments[i];
+                                    if (argument==UNKNOWN_PARAMETER_TYPE) {
+                                        continue;
+                                    }
+                                    while (argument.isArray()) {
+                                        argument = argument.getComponentType();
+                                    }
+                                    ClassNode parameterized = GenericsUtils.parameterizeType(argument, type);
+                                    // retrieve the type of the generics placeholder we're looking for
+                                    // For example, if we have List<T> in the signature and List<String> as an argument
+                                    // we want to align T with String
+                                    // but first test is for Object<T> -> String which explains we don't use the generics types
+
+                                    if (type.isGenericsPlaceHolder()) {
+                                        String name = type.getGenericsTypes()[0].getName();
+                                        if (name.equals(placeholderName)) {
+                                            if (resolvedMethodGenerics.containsKey(name)) {
+                                                failure |= !GenericsUtils.buildWildcardType(resolvedMethodGenerics.get(name)).isCompatibleWith(parameterized);
+                                            } else {
+                                                resolvedMethodGenerics.put(name, parameterized);
+                                            }
+                                        }
+                                    } else {
+                                        if (type.isUsingGenerics() && type.getGenericsTypes()!=null) {
+                                            // we have a method parameter type which is for example List<T>
+                                            // and an actual argument which is FooList
+                                            // which has been aligned to List<E> thanks to parameterizeType
+                                            // then in theory both the parameterized type and the method parameter type
+                                            // are the same type but with different type arguments
+                                            // that we need to align
+                                            GenericsType[] gtInParameter = type.getGenericsTypes();
+                                            GenericsType[] gtInArgument = parameterized.getGenericsTypes();
+                                            if (gtInArgument!=null && gtInArgument.length==gtInParameter.length) {
+                                                for (int j = 0; j < gtInParameter.length; j++) {
+                                                    GenericsType genericsType = gtInParameter[j];
+                                                    if (genericsType.getName().equals(placeholderName)) {
+                                                        ClassNode actualType = gtInArgument[j].getType();
+                                                       if (gtInArgument[j].isPlaceholder()
+                                                                && gtInArgument[j].getName().equals(placeholderName)
+                                                                && resolvedMethodGenerics.containsKey(placeholderName)) {
+                                                           // GROOVY-5724
+                                                           actualType = resolvedMethodGenerics.get(placeholderName);
+                                                        }
+                                                        if (resolvedMethodGenerics.containsKey(placeholderName)) {
+                                                            failure |= !GenericsUtils.buildWildcardType(resolvedMethodGenerics.get(placeholderName)).isCompatibleWith(actualType);
+                                                        } else if (!actualType.isGenericsPlaceHolder()) {
+                                                            resolvedMethodGenerics.put(placeholderName, actualType);
+                                                        }
+                                                    }
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+
+
+            }
+        }
+        if (!failure && genericsTypes!=null) {
+            // last check, verify generic type constraints!
+            for (GenericsType type : genericsTypes) {
+                ClassNode node = resolvedMethodGenerics.get(type.getName());
+                if (node!=null && type.getUpperBounds()!=null) {
+                    // U extends T
+                    for (ClassNode classNode : type.getUpperBounds()) {
+                        if (classNode.isGenericsPlaceHolder()) {
+                            ClassNode resolved = resolvedMethodGenerics.get(classNode.getGenericsTypes()[0].getName());
+                            if (resolved!=null) {
+                                failure |= !GenericsUtils.buildWildcardType(resolved).isCompatibleWith(node);
+                            }
+                        }
+                    }
+                }
+                if (type.getLowerBound()!=null) {
+                    ClassNode resolved = resolvedMethodGenerics.get(type.getLowerBound().getGenericsTypes()[0].getName());
+                    if (resolved!=null) {
+                        failure = !GenericsUtils.buildWildcardType(node).isCompatibleWith(resolved);
+                    }
+                }
+            }
+        }
+        return !failure;
+    }
+
     /**
      * A DGM-like method which adds support for method calls which are handled
      * specifically by the Groovy compiler.
diff --git a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
index 5de0bc9010..77fc4e983e 100644
--- a/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
+++ b/src/main/org/codehaus/groovy/transform/stc/StaticTypeCheckingVisitor.java
@@ -463,10 +463,14 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     && isAssignment(enclosingBinaryExpression.getOperation().getType())
                     && !lType.isArray()) {
                 // left hand side of an assignment : map['foo'] = ...
-                ClassNode[] arguments = {rType, getType(enclosingBinaryExpression.getRightExpression())};
+                Expression enclosingBE_rightExpr = enclosingBinaryExpression.getRightExpression();
+                if (!(enclosingBE_rightExpr instanceof ClosureExpression)) {
+                    enclosingBE_rightExpr.visit(this);
+                }
+                ClassNode[] arguments = {rType, getType(enclosingBE_rightExpr)};
                 List<MethodNode> nodes = findMethod(lType.redirect(), "putAt", arguments);
                 if (nodes.size() == 1) {
-                    typeCheckMethodsWithGenerics(lType, arguments, nodes.get(0), expression);
+                    typeCheckMethodsWithGenericsOrFail(lType, arguments, nodes.get(0), enclosingBE_rightExpr);
                 } else if (nodes.isEmpty()) {
                     addNoMatchingMethodError(lType, "putAt", arguments, enclosingBinaryExpression);
                 }
@@ -1824,7 +1828,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
             for (Receiver<String> currentReceiver : receivers) {
                 mn = findMethod(currentReceiver.getType(), name, args);
                 if (!mn.isEmpty()) {
-                    if (mn.size() == 1) typeCheckMethodsWithGenerics(currentReceiver.getType(), args, mn.get(0), call);
+                    if (mn.size() == 1) typeCheckMethodsWithGenericsOrFail(currentReceiver.getType(), args, mn.get(0), call);
                     chosenReceiver = currentReceiver;
                     break;
                 }
@@ -2189,7 +2193,6 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                     }
 
                     if (!mn.isEmpty()) {
-                        if (mn.size() == 1) typeCheckMethodsWithGenerics(currentReceiver.getType(), args, mn.get(0), call);
                         chosenReceiver = currentReceiver;
                         break;
                     }
@@ -2246,26 +2249,27 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
                                 returnType = md.getType();
                             }
                         }
-                        storeType(call, returnType);
-                        storeTargetMethod(call, directMethodCallCandidate);
-                        String data = chosenReceiver!=null?chosenReceiver.getData():null;
-                        if (data!=null) {
-                            // the method which has been chosen is supposed to be a call on delegate or owner
-                            // so we store the information so that the static compiler may reuse it
-                            call.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, data);
-                        }
-                        // if the object expression is a closure shared variable, we will have to perform a second pass
-                        if (objectExpression instanceof VariableExpression) {
-                            VariableExpression var = (VariableExpression) objectExpression;
-                            if (var.isClosureSharedVariable()) {
-                                SecondPassExpression<ClassNode[]> wrapper = new SecondPassExpression<ClassNode[]>(
-                                        call,
-                                        args
-                                );
-                                typeCheckingContext.secondPassExpressions.add(wrapper);
+                        if (typeCheckMethodsWithGenericsOrFail(chosenReceiver.getType(), args, mn.get(0), call)) {
+                            storeType(call, returnType);
+                            storeTargetMethod(call, directMethodCallCandidate);
+                            String data = chosenReceiver != null ? chosenReceiver.getData() : null;
+                            if (data != null) {
+                                // the method which has been chosen is supposed to be a call on delegate or owner
+                                // so we store the information so that the static compiler may reuse it
+                                call.putNodeMetaData(StaticTypesMarker.IMPLICIT_RECEIVER, data);
+                            }
+                            // if the object expression is a closure shared variable, we will have to perform a second pass
+                            if (objectExpression instanceof VariableExpression) {
+                                VariableExpression var = (VariableExpression) objectExpression;
+                                if (var.isClosureSharedVariable()) {
+                                    SecondPassExpression<ClassNode[]> wrapper = new SecondPassExpression<ClassNode[]>(
+                                            call,
+                                            args
+                                    );
+                                    typeCheckingContext.secondPassExpressions.add(wrapper);
+                                }
                             }
                         }
-
                     } else {
                         addAmbiguousErrorMessage(mn, name, args, call);
                     }
@@ -2786,7 +2790,7 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         MethodNode method = findMethodOrFail(expr, left, operationName, right);
         if (method != null) {
             storeTargetMethod(expr, method);
-            typeCheckMethodsWithGenerics(left, new ClassNode[]{right}, method, expr);
+            typeCheckMethodsWithGenericsOrFail(left, new ClassNode[]{right}, method, expr);
             if (isAssignment(op)) return left;
             if (isCompareToBoolean(op)) return boolean_TYPE;
             if (op == COMPARE_TO) return int_TYPE;
@@ -3585,253 +3589,37 @@ public class StaticTypeCheckingVisitor extends ClassCodeVisitorSupport {
         return resolvedPlaceholders;
     }
 
-    /**
-     * Given a generics type representing SomeClass&lt;T,V&gt; and a resolved placeholder map, returns a new generics type
-     * for which placeholders are resolved recursively.
-     */
-    protected static GenericsType fullyResolve(GenericsType gt, Map<String, GenericsType> placeholders) {
-        GenericsType fromMap = placeholders.get(gt.getName());
-        if (gt.isPlaceholder() && fromMap!=null) {
-            gt = fromMap;
-        }
-
-        ClassNode type = fullyResolveType(gt.getType(), placeholders);
-        ClassNode lowerBound = gt.getLowerBound();
-        if (lowerBound != null) lowerBound = fullyResolveType(lowerBound, placeholders);
-        ClassNode[] upperBounds = gt.getUpperBounds();
-        if (upperBounds != null) {
-            ClassNode[] copy = new ClassNode[upperBounds.length];
-            for (int i = 0, upperBoundsLength = upperBounds.length; i < upperBoundsLength; i++) {
-                final ClassNode upperBound = upperBounds[i];
-                copy[i] = fullyResolveType(upperBound, placeholders);
-            }
-            upperBounds = copy;
-        }
-        GenericsType genericsType = new GenericsType(type, upperBounds, lowerBound);
-        genericsType.setWildcard(gt.isWildcard());
-        return genericsType;
-    }
-
-    protected static ClassNode fullyResolveType(final ClassNode type, final Map<String, GenericsType> placeholders) {
-        if (type.isUsingGenerics() && !type.isGenericsPlaceHolder()) {
-            GenericsType[] gts = type.getGenericsTypes();
-            if (gts != null) {
-                GenericsType[] copy = new GenericsType[gts.length];
-                for (int i = 0; i < gts.length; i++) {
-                    GenericsType genericsType = gts[i];
-                    if (genericsType.isPlaceholder() && placeholders.containsKey(genericsType.getName())) {
-                        copy[i] = placeholders.get(genericsType.getName());
-                    } else {
-                        copy[i] = fullyResolve(genericsType, placeholders);
-                    }
-                }
-                gts = copy;
-            }
-            ClassNode result = type.getPlainNodeReference();
-            result.setGenericsTypes(gts);
-            return result;
-        } else if (type.isUsingGenerics() && OBJECT_TYPE.equals(type) && type.getGenericsTypes() != null) {
-            // Object<T>
-            GenericsType genericsType = placeholders.get(type.getGenericsTypes()[0].getName());
-            if (genericsType != null) {
-                return genericsType.getType();
+    protected boolean typeCheckMethodsWithGenericsOrFail(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod, Expression location) {
+        if (!typeCheckMethodsWithGenerics(receiver, arguments, candidateMethod)) {
+            Map<String, GenericsType> classGTs = GenericsUtils.extractPlaceholders(receiver);
+            ClassNode[] ptypes = new ClassNode[candidateMethod.getParameters().length];
+            final Parameter[] parameters = candidateMethod.getParameters();
+            for (int i = 0; i < parameters.length; i++) {
+                final Parameter parameter = parameters[i];
+                ClassNode type = parameter.getType();
+                ptypes[i] = fullyResolveType(type, classGTs);
             }
-        } else if (type.isArray()) {
-            return fullyResolveType(type.getComponentType(), placeholders).makeArray();
-        }
-        return type;
-    }
-
-    /**
-     * Checks that the parameterized generics of an argument are compatible with the generics of the parameter.
-     *
-     * @param parameterType the parameter type of a method
-     * @param argumentType  the type of the argument passed to the method
-     */
-    protected boolean typeCheckMethodArgumentWithGenerics(ClassNode parameterType, ClassNode argumentType, boolean lastArg) {
-        if (UNKNOWN_PARAMETER_TYPE == argumentType) {
-            // called with null
-            return true;
-        }
-        if (!isAssignableTo(argumentType, parameterType) && !lastArg) {
-            // incompatible assignment
+            addStaticTypeError("Cannot call " + toMethodGenericTypesString(candidateMethod) + receiver.toString(false) + "#" +
+                    toMethodParametersString(candidateMethod.getName(), ptypes) +
+                    " with arguments " + formatArgumentList(arguments), location);
             return false;
         }
-        if (!isAssignableTo(argumentType, parameterType) && lastArg) {
-            if (parameterType.isArray()) {
-                if (!isAssignableTo(argumentType, parameterType.getComponentType())) {
-                    return false;
-                }
-            }
-        }
-        if (parameterType.isUsingGenerics() && argumentType.isUsingGenerics()) {
-            GenericsType gt = GenericsUtils.buildWildcardType(parameterType);
-            if (!gt.isCompatibleWith(argumentType)) {
-                return false;
-            }
-        } else if (parameterType.isArray() && argumentType.isArray()) {
-            // verify component type
-            typeCheckMethodArgumentWithGenerics(parameterType.getComponentType(), argumentType.getComponentType(), lastArg);
-        } else if (lastArg && parameterType.isArray()) {
-            // verify component type, but if we reach that point, the only possibility is that the argument is
-            // the last one of the call, so we're in the cast of a vargs call
-            // (otherwise, we face a type checker bug)
-            typeCheckMethodArgumentWithGenerics(parameterType.getComponentType(), argumentType, lastArg);
-        }
         return true;
     }
 
-    protected void typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod, Expression location) {
-        if (CLASS_Type.equals(receiver)
-                && receiver.isUsingGenerics()
-                && candidateMethod.getDeclaringClass() != receiver
-                && !(candidateMethod instanceof ExtensionMethodNode)) {
-            typeCheckMethodsWithGenerics(receiver.getGenericsTypes()[0].getType(), arguments, candidateMethod, location);
-            return;
-        }
-        boolean failure = false;
-        // both candidate method and receiver have generic information so a check is possible
-        Parameter[] parameters = candidateMethod.getParameters();
-        GenericsType[] genericsTypes = candidateMethod.getGenericsTypes();
-        boolean methodUsesGenerics = (genericsTypes != null && genericsTypes.length > 0);
-        boolean isExtensionMethod = candidateMethod instanceof ExtensionMethodNode;
-        if (isExtensionMethod && methodUsesGenerics) {
-            ClassNode[] dgmArgs = new ClassNode[arguments.length + 1];
-            dgmArgs[0] = receiver;
-            System.arraycopy(arguments, 0, dgmArgs, 1, arguments.length);
-            MethodNode extensionMethodNode = ((ExtensionMethodNode) candidateMethod).getExtensionMethodNode();
-
-            // if it's an extension method, we can infer some of the actual parameterized types of the method
-            // from the receiver (and only the receiver)
-            Parameter[] dgmMethodArgs = extensionMethodNode.getParameters();
-            ClassNode dgmMethodFirstArgType = dgmMethodArgs[0].getType();
-
-            // todo: what if it's not an interface?
-            if (dgmMethodFirstArgType.isUsingGenerics() && dgmMethodFirstArgType.isInterface()) {
-                ClassNode firstArgType = GenericsUtils.parameterizeType(receiver, dgmMethodFirstArgType);
-
-
-                Map<String, GenericsType> placeholders = new HashMap<String, GenericsType>();
-                GenericsType[] gts = dgmMethodFirstArgType.getGenericsTypes();
-                for (int i = 0; gts != null && i < gts.length; i++) {
-                    GenericsType gt = gts[i];
-                    if (gt.isPlaceholder()) {
-                        placeholders.put(gt.getName(), firstArgType.getGenericsTypes()[i]);
-                    }
-                }
-
-                Parameter[] dgmMethodArgsWithPlaceholdersReplaced = new Parameter[dgmMethodArgs.length];
-                dgmMethodArgsWithPlaceholdersReplaced[0] = new Parameter(firstArgType, "self");
-                for (int i = 1; i < dgmMethodArgsWithPlaceholdersReplaced.length; i++) {
-                    ClassNode substitute = dgmMethodArgs[i].getType();
-                    substitute = fullyResolveType(substitute, placeholders);
-                    dgmMethodArgsWithPlaceholdersReplaced[i] = new Parameter(substitute, "arg" + i);
-                }
-                MethodNode vdgm = new MethodNode(
-                        extensionMethodNode.getName(),
-                        extensionMethodNode.getModifiers(),
-                        extensionMethodNode.getReturnType(),
-                        dgmMethodArgsWithPlaceholdersReplaced,
-                        extensionMethodNode.getExceptions(),
-                        EmptyStatement.INSTANCE
-                );
-                typeCheckMethodsWithGenerics(extensionMethodNode.getDeclaringClass(), dgmArgs, vdgm, location);
-                return;
+    private String toMethodGenericTypesString(MethodNode node) {
+        GenericsType[] genericsTypes = node.getGenericsTypes();
+        if (genericsTypes ==null) return "";
+        StringBuilder sb = new StringBuilder("<");
+        for (int i = 0; i < genericsTypes.length; i++) {
+            final GenericsType genericsType = genericsTypes[i];
+            sb.append(genericsType.toString());
+            if (i<genericsTypes.length-1) {
+                sb.append(",");
             }
         }
-        Map<String, GenericsType> classGTs = GenericsUtils.extractPlaceholders(receiver);
-        if (parameters.length > arguments.length) {
-            // this is a limitation that must be removed in a future version
-            // we cannot check generic type arguments if there are default parameters!
-            return;
-        }
-        Map<String, ClassNode> resolvedMethodGenerics = new HashMap<String, ClassNode>();
-        ClassNode[] ptypes = new ClassNode[candidateMethod.getParameters().length];
-        final GenericsType[] methodNodeGenericsTypes = candidateMethod.getGenericsTypes();
-        final boolean shouldCheckMethodGenericTypes = methodNodeGenericsTypes!=null && methodNodeGenericsTypes.length>0;
-        for (int i = 0; i < arguments.length; i++) {
-            int pindex = Math.min(i, parameters.length - 1);
-            ClassNode type = parameters[pindex].getType();
-            type = fullyResolveType(type, classGTs);
-            ptypes[pindex] = type;
-            failure |= !typeCheckMethodArgumentWithGenerics(type, arguments[i], i >= parameters.length - 1);
-            if (shouldCheckMethodGenericTypes && !failure) {
-                // GROOVY-5692
-                // for example: public <T> foo(T arg0, List<T> arg1)
-                // we must check that T for arg0 and arg1 are the same
-                // so that if you call foo(String, List<Integer>) the compiler fails
-
-                // For that, we store the information for each argument, and for a new argument, we will
-                // check that is is the same as the previous one
-                GenericsType[] typeGenericsTypes = type.getGenericsTypes();
-                if (type.isUsingGenerics() && typeGenericsTypes !=null) {
-                    for (int gtIndex = 0, typeGenericsTypesLength = typeGenericsTypes.length; gtIndex < typeGenericsTypesLength; gtIndex++) {
-                        final GenericsType typeGenericsType = typeGenericsTypes[gtIndex];
-                        if (typeGenericsType.isPlaceholder()) {
-                            for (GenericsType methodNodeGenericsType : methodNodeGenericsTypes) {
-                                String placeholderName = methodNodeGenericsType.getName();
-                                if (methodNodeGenericsType.isPlaceholder() && placeholderName.equals(typeGenericsType.getName())) {
-                                    // match!
-                                    ClassNode parameterized = GenericsUtils.parameterizeType(arguments[i], type);
-                                    // retrieve the type of the generics placeholder we're looking for
-                                    // For example, if we have List<T> in the signature and List<String> as an argument
-                                    // we want to align T with String
-                                    // but first test is for Object<T> -> String which explains we don't use the generics types
-
-                                    if (type.isGenericsPlaceHolder()) {
-                                        String name = type.getGenericsTypes()[0].getName();
-                                        if (name.equals(placeholderName)) {
-                                            if (resolvedMethodGenerics.containsKey(name)) {
-                                                failure |= !resolvedMethodGenerics.get(name).equals(parameterized);
-                                            } else {
-                                                resolvedMethodGenerics.put(name, parameterized);
-                                            }
-                                        }
-                                    } else {
-                                        if (type.isUsingGenerics() && type.getGenericsTypes()!=null) {
-                                            // we have a method parameter type which is for example List<T>
-                                            // and an actual argument which is FooList
-                                            // which has been aligned to List<E> thanks to parameterizeType
-                                            // then in theory both the parameterized type and the method parameter type
-                                            // are the same type but with different type arguments
-                                            // that we need to align
-                                            GenericsType[] gtInParameter = type.getGenericsTypes();
-                                            GenericsType[] gtInArgument = parameterized.getGenericsTypes();
-                                            if (gtInArgument!=null && gtInArgument.length==gtInParameter.length) {
-                                                for (int j = 0; j < gtInParameter.length; j++) {
-                                                    GenericsType genericsType = gtInParameter[j];
-                                                    if (genericsType.getName().equals(placeholderName)) {
-                                                        ClassNode actualType = gtInArgument[j].getType();
-                                                       if (gtInArgument[j].isPlaceholder()
-                                                                && gtInArgument[j].getName().equals(placeholderName)
-                                                                && resolvedMethodGenerics.containsKey(placeholderName)) {
-                                                           // GROOVY-5724
-                                                           actualType = resolvedMethodGenerics.get(placeholderName);
-                                                        }
-                                                        if (resolvedMethodGenerics.containsKey(placeholderName)) {
-                                                            failure |= !resolvedMethodGenerics.get(placeholderName).equals(actualType);
-                                                        } else {
-                                                            resolvedMethodGenerics.put(placeholderName, actualType);
-                                                        }
-                                                    }
-                                                }
-                                            }
-                                        }
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-
-
-            }
-        }
-        if (failure) {
-            addStaticTypeError("Cannot call " + receiver.getName() + "#" +
-                    toMethodParametersString(candidateMethod.getName(), ptypes) +
-                    " with arguments " + formatArgumentList(arguments), location);
-        }
+        sb.append("> ");
+        return sb.toString();
     }
 
     protected static String formatArgumentList(ClassNode[] nodes) {
diff --git a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
index 58d3f8e5be..cebe4c68c9 100644
--- a/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/ArraysAndCollectionsSTCTest.groovy
@@ -380,7 +380,7 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             String[] arr = ['abc']
             arr.putAt(0, new Object())
-        ''', 'Cannot find matching method [Ljava.lang.String;#putAt(int, java.lang.Object)'
+        ''', 'Cannot call <T,U extends T> java.lang.String[]#putAt(int, U) with arguments [int, java.lang.Object]'
     }
 
     void testStringArrayPutWithSubType() {
@@ -401,7 +401,7 @@ class ArraysAndCollectionsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             Serializable[] arr = ['abc']
             arr.putAt(0, new XmlSlurper())
-        ''', 'Cannot find matching method [Ljava.io.Serializable;#putAt(int, groovy.util.XmlSlurper)'
+        ''', 'Cannot call <T,U extends T> java.io.Serializable[]#putAt(int, U) with arguments [int, groovy.util.XmlSlurper]'
     }
 
     void testArrayGetOnPrimitiveArray() {
diff --git a/src/test/groovy/transform/stc/GenericsSTCTest.groovy b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
index 5bded69a37..973cc3faef 100644
--- a/src/test/groovy/transform/stc/GenericsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/GenericsSTCTest.groovy
@@ -72,7 +72,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<String> list = []
             list << 1
-        ''', 'Cannot find matching method java.util.List#leftShift(int)'
+        ''', 'Cannot call <T> java.util.List <String>#leftShift(T) with arguments [int]'
     }
 
     void testAddOnList2UsingLeftShift() {
@@ -119,7 +119,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
         shouldFailWithMessages '''
             List<Integer> list = new LinkedList<>()
             list << 'Hello'
-        ''', 'Cannot find matching method java.util.LinkedList#leftShift(java.lang.String)'
+        ''', 'Cannot call <T> java.util.LinkedList <java.lang.Integer>#leftShift(T) with arguments [java.lang.String]'
     }
 
     void testAddOnListWithDiamondAndNullUsingLeftShift() {
@@ -484,7 +484,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             List<String> list = ['a','b','c']
             Collection<Integer> e = (Collection<Integer>) [1,2,3]
             boolean r = list.addAll(e)
-        ''', 'Cannot call org.codehaus.groovy.runtime.DefaultGroovyMethods#addAll(java.util.Collection <java.lang.String>, java.lang.String[]) with arguments [java.util.List <java.lang.String>, java.util.Collection <Integer>]'
+        ''', 'Cannot call <T> java.util.List <java.lang.String>#addAll(T[]) with arguments [java.util.Collection <Integer>]'
     }
 
     // GROOVY-5528
@@ -725,7 +725,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map['foo'] = new Date()
-        ''', 'Cannot call org.codehaus.groovy.runtime.DefaultGroovyMethods#putAt(java.util.Map <java.util.Date, java.util.Date>, java.util.Date, java.util.Date) with arguments [java.util.HashMap <java.util.Date, java.util.Date>, java.lang.String, java.util.Date]'
+        ''', 'Cannot call <K,V> java.util.HashMap <java.util.Date, java.util.Date>#putAt(java.util.Date, java.util.Date) with arguments [java.lang.String, java.util.Date]'
     }
     void testInferDiamondForAssignmentWithDatesAndIllegalValueUsingPut() {
         shouldFailWithMessages '''
@@ -763,7 +763,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             })
             Map<Date, Date> map = new HashMap<>()
             map[new Date()] = 'foo'
-        ''', 'Cannot assign value of type java.lang.String to variable of type java.util.Date'
+        ''', 'Cannot call <K,V> java.util.HashMap <java.util.Date, java.util.Date>#putAt(java.util.Date, java.util.Date) with arguments [java.util.Date, java.lang.String]'
     }
 
     void testCallMethodWithParameterizedArrayList() {
@@ -1278,8 +1278,7 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             class Blah {}
             class MyList extends LinkedList<Object> {}
             List<Blah> o = new MyList()
-        ''',
-        'Incompatible generic argument types. Cannot assign MyList to: java.util.List <Blah>'
+        ''','Incompatible generic argument types. Cannot assign MyList to: java.util.List <Blah>'
         
         // Groovy-5873
         assertScript """
@@ -1350,7 +1349,35 @@ class GenericsSTCTest extends StaticTypeCheckingTestCase {
             assert l == []
         '''
     }
-    
+
+    // GROOVY-6504
+    void testInjectMethodWithInitialValueChoosesTheCollectionVersion() {
+        assertScript '''import org.codehaus.groovy.transform.stc.ExtensionMethodNode
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def method = node.rightExpression.getNodeMetaData(DIRECT_METHOD_CALL_TARGET)
+                assert method.name == 'inject'
+                assert method instanceof ExtensionMethodNode
+                method = method.extensionMethodNode
+                assert method.parameters[0].type == make(Collection)
+            })
+            def result = ['a','bb','ccc'].inject(0) { int acc, String str -> acc += str.length(); acc }
+            assert  result == 6
+        '''
+    }
+
+    // GROOVY-6504
+    void testInjectMethodWithInitialValueChoosesTheCollectionVersionUsingDGM() {
+        assertScript '''import org.codehaus.groovy.runtime.DefaultGroovyMethods
+            @ASTTest(phase=INSTRUCTION_SELECTION, value={
+                def method = node.rightExpression.getNodeMetaData(DIRECT_METHOD_CALL_TARGET)
+                assert method.name == 'inject'
+                assert method.parameters[0].type == make(Collection)
+            })
+            def result = DefaultGroovyMethods.inject(['a','bb','ccc'],0, { int acc, String str -> acc += str.length(); acc })
+            assert  result == 6
+        '''
+    }
+
     static class MyList extends LinkedList<String> {}
 
     public static class ClassA<T> {
diff --git a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
index b3a17e2f80..9c6d890bfd 100644
--- a/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
+++ b/src/test/groovy/transform/stc/MethodCallsSTCTest.groovy
@@ -188,7 +188,7 @@ class MethodCallsSTCTest extends StaticTypeCheckingTestCase {
             B c = new B<Integer>()
             String[] args = ['a','b','c']
             assert c.identity(args) == args
-        ''', 'Cannot call groovy.transform.stc.MethodCallsSTCTest$MyMethodCallTestClass2#identity(java.lang.Integer[]) with arguments [java.lang.String[]]'
+        ''', 'Cannot find matching method groovy.transform.stc.MethodCallsSTCTest$MyMethodCallTestClass2#identity(java.lang.String[])'
     }
 
     void testMethodCallFromSuperOwner() {
